_Последние изменения внесены: 21.03.2023_

# Модуль `collections` стандартной бибилиотеки Python.

* Модуль `collections` входит в стандартную бибилиотеку **Python** и не требует отдельной установки.
* Данный модуль содержит специальные типы данных **Python**, которые реализованы на осовании встроенных, таких как *списки*, *словари*, *кортежи итд*.

## Содержание:
#### 1. Класс `Counter`
#### 2. Специальный тип данных `defaultdict` ("Словарь по умолчанию")

## 1. Класс `Counter`

* Класс `Counter` используется для подсчета значений. 
* Даннный класс построен на основании встроенного типа данных `dict` - словарь.
* Как и в случае со стандартными словарями, ключами могут быть только неизменяемые типы данных, которые поддерживают хэширование.
* Для работы класса **необходима итерабильная последовательность** элементы которой можно перебирать.

Рассмотрим примеры реализации возможностей данного класса:


```python
from collections import Counter
```


```python
string = 'abracadabra'
```


```python
Counter(string)
```




    Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})




```python
print(type(Counter(string)))
```

    <class 'collections.Counter'>
    

* В результате мы получаем новый объект класса `Counter`
* Содержимое очень похоже на **словарь**, где ключи это буквы, а значение кол-во раз сколько они втсречаются в объекте **string**

Точно так же можно обработать **данные списка**:


```python
my_list = ['one', 'two', 'three', 'two', 'three', 'three']
```


```python
Counter(my_list)
```




    Counter({'one': 1, 'two': 2, 'three': 3})



Данные класса `Counter` мы можем поместить в переменную и обратится к ним в любой момент:


```python
data = Counter(my_list)
```


```python
data
```




    Counter({'one': 1, 'two': 2, 'three': 3})



* Получили тот же результат.

### 1.2 Обращение `по ключу` и применение стандартных методов методов `.items()`  ,  `.keys()`  ,  `values()`

Поскольку мы имее дело со словарем, то к его значениям мы можем напрямую обращаться по ключам, а так же применять стандартные методы работы со словарями:


```python
data['three']
```




    3



* Получено верное значение по указанному ключу.

Интересная особенность класса `Counter`:
* При обращение по ключу которого не существет, мы не получим ошибку, как при работе со стандартным словарем **Python**
* Поскольку данные класс занимается подсчетом частоты, с которой элемент встречается в обрабатываемых данных, то результатом поиска несуществующего ключа будет 0.


```python
data['five']
```




    0



* Результат озночает что ключ **'five'** встречался 0 раз.

Применим стандартные методы `.items()`  ,  `.keys()`  ,  `values()`


```python
data.items()
```




    dict_items([('one', 1), ('two', 2), ('three', 3)])



* В результате получаем список кортежей, содержащих пару ключ: значение.


```python
data.keys()
```




    dict_keys(['one', 'two', 'three'])



* В результате получаем список, элементами которого являются ключи словаря.


```python
data.values()
```




    dict_values([1, 2, 3])



* В результате получаем список, элементами которого являются значения ключей словаря.

### 1.3 применение специальных методов класса `Counter`

### метод `.elements()`


```python
Counter(my_list).elements()
```




    <itertools.chain at 0x2153e85c130>



* В результате применения метода `.elements()` мы получаем **объект итератор**, **элементы** которого можно обойти в **цикле**:


```python
for el in Counter(my_list).elements():
    print(el)
```

    one
    two
    two
    three
    three
    three
    

* В данном цикле `итерация` происходит по ключам нашего `объекта-каунтера` **Counter(my_list)** и каждый ключ выводится столько раз, сколько он встречается в исходном списке **my_lyst**

### метод `.most_common()`

Метод возвращает пару ключ: значение начиная с самого часто встречающего елемента данных и далее в прядке убывания:


```python
Counter(my_list).most_common()
```




    [('three', 3), ('two', 2), ('one', 1)]



* Результатом работы метода `.most_common()` будет **список**, отдельным элементом которого является **кортеж**.

Метод может принимать один аргумент, который позволяет выводить на экран определенное кол-во элементов:


```python
Counter(my_list).most_common(2)
```




    [('three', 3), ('two', 2)]



* В результаты вывелись только два самых часто встречающихся в списке элемента.

**Пример применения:**


```python
#Создадим пустой объект класса Counter
count = Counter()
print(count)
```

    Counter()
    


```python
#Посчитаем кол-во повторений элементов списка
my_list = ['a', 'b', 'c', 'b', 'c', 'c', 'd']

for i in my_list:
    count[i] = count[i] + 1
print(count)
```

    Counter({'c': 12, 'b': 8, 'a': 4, 'd': 4})
    

* Такой метод подсчета возможен только с применением `Counter()` так как при отсутсвии ключа в словаре будет возвращен 0.
* Следовательно при первом обращении по ключу, которого еще нет в словаре выражение `count[i] = count[i] + 1` будет реализовано в **Python** в следующем виде: `count[i] = 0 + 1`
* Если мы попытаемся спользовать стандартный словарь *Python* в данной ситуации, то возникнет ошибка, так как ключа `[i]` и его значения в словаре нет, а значит провести матичесскую операцию сложения с несуществующими данными мы не можем.

**Рассмотрим еще один пример: `Сложение и вычетание объектов-счетчиков`** 


```python
#Используем тот же список:
my_list = ['a', 'b', 'c', 'b', 'c', 'c', 'd']
data = Counter(my_list) #помести в переменну data данные объекта класса Counter
print(data)
```

    Counter({'c': 3, 'b': 2, 'a': 1, 'd': 1})
    


```python
#Создадим еще один спискок:
new_list = ['y', 'y', 'y', 'y', 'd', 'd', 'd', 'd']
new_data = Counter(new_list) #помести в переменну new_data данные объекта класса Counter
print(new_data)
```

    Counter({'y': 4, 'd': 4})
    

Работа с классом `Counter()` позволяет нам сложить результаты: 


```python
results = data + new_data
print(results)
```

    Counter({'d': 5, 'y': 4, 'c': 3, 'b': 2, 'a': 1})
    

* В результате мы получим объединенный объект-счетчик **results**, где будут содержаться уникальные пары ключ:значение из объектов-счетчиков **data** и **new_data**, которые мы сложили, а по совпадающим ключам, значения будут складываться.

Произведем вычетание:


```python
new_results = data - new_data
print(new_results)
```

    Counter({'c': 3, 'b': 2, 'a': 1})
    


```python
new_results_2 = new_data - data
print(new_results_2)
```

    Counter({'y': 4, 'd': 3})
    

* В результате остануться только те пары **ключ:значение**, где **значение ключа** после вычитания **будут положительными**.


```python

```
