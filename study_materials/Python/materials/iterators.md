*Последние изменения внесены: `04.04.2023`*

[<<< Предыдущее меню.](/study_materials/Python/Python_study_materials.md)

# Итераторы и Итерируемые объекты.

### Итерируемые объекты.

* **Итерируемый объект** это объект, который можно проитерировать, т.е. пройтись по элементам объекта в цикле. 
* Например, итерируемым объектом может быть список или кортеж. 
* В **Python**, чтобы объект был итерируемым, он должен реализовывать метод `__iter__`. 
* Этот метод-болванка принимает в качестве входных данных только экземпляр объекта `self` и должен возвращать объект-итератор. 
* Вы можете использовать встроенную функцию `iter`, чтобы получить итератор итерируемого объекта.
* В **Python** последовательности сами по себе не являются итераторами. Скорее у каждой есть соответствующий класс-итератор, отвечающий за итерацию. 

Пример преобразования списка в итерируемый объект (объект класса-итератора):


```python
l = [1, 2, 3, 4, 5]

it_1 = iter(l)

print(type(it_1))
```

    <class 'list_iterator'>
    

> Итерируемый объект не обязательно является итератором. Поскольку на самом деле сам по себе он не выполняет итерацию. У вас может быть отдельный объект-итератор, который возвращается из итерируемого класса, а не класс, обрабатывающий свою собственную итерацию.

### Итераторы.

* `Итераторы` – это уровень абстракции, который инкапсулирует знания о том, как брать элементы из некоторой последовательности. 
* `Итератор` - это класс, реализующий магичесские методы `__next__` и `__iter__`. 
* «Последовательность», с которой работает `итератор` может быть чем угодно, от списков и файлов до потоков данных из базы данных или удаленного сервиса. 
* В итераторах замечательно то, что код, использующий итератор, даже не должен знать, какой источник данных используется, а вместо этого он может сосредоточиться только на одном, а именно: «Что мне делать с каждым элементом?».


```python
l = [1, 2, 3, 4, 5]

it_1 = iter(l)

print(next(it_1)) # Итерация 1
print(next(it_1)) # Итерация 2
print(next(it_1)) # Итерация 3
print(next(it_1)) # Итерация 4
print(next(it_1)) # Итерация 5
print(next(it_1)) # Итерация 6 - индекс очередного элемента выходит за пределы списка, мы вызываем StopIteration 
```

    1
    2
    3
    4
    5
    


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[27], line 10
          8 print(next(it_1)) # Итерация 4
          9 print(next(it_1)) # Итерация 5
    ---> 10 print(next(it_1))
    

    StopIteration: 


> Все циклы `for` в **Python** используют итераторы:


```python
chars = 'abc'

for char in chars:
    print(char)
```

    a
    b
    c
    

По сути в цикле `for` происходит следующее:


```python
chars = iter('ABC')
print(next(chars))
print(next(chars))
print(next(chars))

```

    A
    B
    C
    

Попытка обратится к следующему несуществующему элементу вызовит исключение `StopIteration`:


```python
print(next(chars))
```


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[7], line 1
    ----> 1 print(next(chars))
    

    StopIteration: 


**Реализация итератора чисел Фибонначи в парадигме ООП:**


```python
class Fib:
    
    def __init__(self, max_items):
        self.max_items = max_items
        
    def __next__(self):
        self.items += 1
        if self.items > self.max_items:
            raise StopIteration
    
        self.fib = self.a
        self.a, self.b = self.b, self.a + self.b
        return self.fib
    
    def __iter__(self):
        self.a = 0
        self.b = 1
        self.items = 0
        return self
    
if __name__ == '__main__':
    
    fib = Fib(10)
    
    for item in fib:
        print(item)       
```

    0
    1
    1
    2
    3
    5
    8
    13
    21
    34
    

[<<< Предыдущее меню.](/study_materials/Python/Python_study_materials.md)


```python

```
