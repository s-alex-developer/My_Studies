*Последние изменения внесены 16.04.2023*

[Видео лекции (перейти и скачать)]()

# SQL - Structured Query Language

**SQL** — это язык структурированных запросов. Данный язык понимает СУБД, которая и производит операции с данными.

## Типы запросов в SQL
* **DDL** (Data Definition Language) - `CREATE`, `ALTER`, `DROP` (управление таблицами)
* **DML** (Data Manipulation Language) - `SELECT`, `INSERT`, `UPDATE`, `DELETE` (управление данными внутри таблицы)
* **TCL** (Transaction Control Language) - `COMMIT`, `ROLLBACK`, `SAVEPOINT` (управление транзакциями)
* **DCL** (Data Control Language) - `GRANT`, `REVOKE`, `DENY` (управление пользователями и их правами)

# DDL (Data Definition Language)

## 1.1 `CREATE TABLE` - создание таблиц.

###  Шаблон запроса на создание таблицы:

```mysql
CREATE TABLE IF NOT EXISTS <имя таблицы> (
    <имя_столбца_1> <тип_данных_1> [CONSTRAINTS],
    <имя_столбца_N> <cтип_данных_N> [CONSTRAINTS],
    ...);
```

* `IF NOT EXISTS` - необязательный параметр, если таблица уже существует никакие действия по данному запросу выполнятся не будут и выполнение других запросов продолжится дальше. 

## 1.2 Основные типы данных:
* При определении таблицы для всех ее столбцов необходимо указать тип данных. 
* Тип данных определяет диапазон значений, которые могут храниться в столбце, сколько они будут занимать места в памяти. 
* **PostgreSQL** поддерживает богатую палитру различных типов данных, среди которые условно можно разделить на подгруппы:
    * числовые
    * символьные
    * логические
    * дата и время
    * бинарные 
    * и ряд других.

### `Числовые типы данных:`
* **serial**: представляет автоинкрементирующееся числовое значение, которое занимает 4 байта и может хранить числа от 1 до 2147483647. Значение данного типа образуется путем автоинкремента значения предыдущей строки. Поэтому, как правило, данный тип используется для определения идентификаторов строки.
***
* **smallserial**: представляет автоинкрементирующееся числовое значение, которое занимает 2 байта и может хранить числа от 1 до 32767. Аналог типа serial для небольших чисел.
***
* **bigserial**: представляет автоинкрементирующееся числовое значение, которое занимает 8 байт и может хранить числа от 1 до 9223372036854775807. Аналог типа serial для больших чисел.
***
* **smallint**: хранит числа от -32768 до +32767. Занимает 2 байта. Имеет псевдоним int2.
***
* **integer**: хранит числа от -2147483648 до +2147483647. Занимает 4 байта. Имеет псевдонимы int и int4.
***
* **bigint**: хранит числа от -9223372036854775808 до +9223372036854775807. Занимает 8 байт. Имеет псевдоним int8.
***
* **numeric**: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков после запятой.

    * Данный тип может принимать два параметра **precision** и **scale**: numeric(precision, scale).

    * Параметр **precision** указывает на максимальное количество цифр, которые может хранить число.

    * Параметр **scale** представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра **precision**. По умолчанию оно равно 0.

    * Например, для числа 23.5141 precision равно 6, а scale - 4.
***
* **decimal**: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков в дробной части. То же самое, что и numeric.
***
* **real**: хранит числа с плавающей точкой из диапазона от 1E-37 до 1E+37. Занимает 4 байта. Имеет псевдоним float4.
***
* **double precision**: хранит числа с плавающей точкой из диапазона от 1E-307 до 1E+308. Занимает 8 байт. Имеет псевдоним float8.

### `Типы для работы с валютой (денежными единицами):`
* Для работы с денежными единицами определен тип **money**, который может принимать значения в диапазоне от -92233720368547758.08 до +92233720368547758.07 и занимает 8 байт.

### `Символьные типы:`
* **character(n)**: представляет строку из фиксированного количества символов. С помощью параметра задается задается количество символов в строке. Имеет псевдоним **char(n)**.
***
* **character varying(n)**: представляет строку из переменной длины. С помощью параметра задается задается максимальное количество символов в строке. Имеет псевдоним **varchar(n)**.
***
* **text**: представляет текст произвольной длины.

### `Бинарные данные:`
* Для хранения бинарных данных определен тип **bytea**. Он хранит данные в виде бинарных строк, которые представляют последовательность октетов или байт.

### `Типы для работы с датами и временем:`
* **timestamp**: хранит дату и время. Занимает 8 байт. Для дат самое нижнее значение - 4713 г до н.э., самое верхнее значение - 294276 г н.э.
***
* **timestamp with time zone**: то же самое, что и timestamp, только добавляет данные о часовом поясе.
***
* **date**: представляет дату от 4713 г. до н.э. до 5874897 г н.э. Занимает 4 байта.
***
* **time**: хранит время с точностью до 1 микросекунды без указания часового пояса. Принимает значения от 00:00:00 до 24:00:00. Занимает 8 байт.
***
* **time with time zone**: хранит время с точностью до 1 микросекунды с указанием часового пояса. Принимает значения от 00:00:00+1459 до 24:00:00-1459. Занимает 12 байт.
***
* **interval**: представляет временной интервал. Занимает 16 байт.
***
**Распространенные форматы дат:**

yyyy-mm-dd - 1999-01-08

Month dd, yyyy - January 8, 1999

mm/dd/yyyy - 1/8/1999

**Распространенные форматы времени:**

hh:mi - 13:21

hh:mi am/pm - 1:21 pm

hh:mi:ss - 1:21:34

### `Логический тип:`
* Тип **boolean** может хранить одно из двух значений: **true** или **false**.
***
* Вместо **true** можно указывать следующие значения: 
    * TRUE 
    * 't'
    * 'true' 
    * 'y'
    * 'yes' 
    * 'on' 
    * '1'
****
* Вместо **false** можно указывать следующие значения: 
    * FALSE 
    * 'f'
    * 'false'
    * 'n'
    * 'no'
    * 'off'
    * '0'

### `Типы для представления интернет-адресов:`
* **cidr**: интернет-адрес в формате IPv4 и IPv6. Например, 192.168.0.1. Занимает от 7 до 19 байт.
***
* **inet**: интернет-адрес в формате cidr/y, где cidr это адрес в формате IPv4 или IPv6, а /y - количество бит в адресе (если этот параметр не указан, то используется 34 для IPv4, 128 для IPv6). Например, 192.168.0.1/24 или 2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128. Занимает от 7 до 19 байт.
***
* **macaddr**: хранит MAC-адрес. Занимает 6 байт.
***
* **macaddr8**: хранит MAC-адрес в формате EUI-64. Занимает 8 байт.

### `Геометрические типы:`
* **point**: представляет точку на плоскости в формате (x,y). Занимает 16 байт.
***
* **line**: представляет линию неопределенной длины в формате {A,B,C}. Занимает 32 байта.
***
* **lseg**: представляет отрезок в формате ((x1,y1),(x2,y2)). Занимает 32 байта.
***
* **box**: представляет прямоугольник в формате ((x1,y1),(x2,y2)). Занимает 32 байта.
***
* **path**: представляет набор содиненных точек. В формате ((x1,y1),...) путь является закрытым (первая и последняя точка соединяются линией) и фактически представляет многоугольник. В формате [(x1,y1),...] путь является открытым Занимает 16+16n байт.
***
* **polygon**: представляет многоугольник в формате ((x1,y1),...). Занимает 40+16n байт.
***
* **circle**: представляет окружность в формате <(x,y),r>. Занимает 24 байта.

### `Остальные типы данных:`
* **json**: хранит данные json в текстовом виде.
***
* **jsonb**: хранит данные json в бинарном формате.
***
* **uuid**: хранит универсальный уникальный идентификатор (UUID), например, a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11. Занимает 32 байта.
***
* **xml**: хранит даные в формате XML.

## 1.3 Ограничения и оператор `CONSTRAINT`:

* При определении таблиц и их столбцов в SQL мы можем использовать ряд атрибутов, которые накладывают определенные ограничения.

 **Рассмотрим эти атрибуты:**

### `PRIMARY KEY` - первичный ключ.

**С помощью выражения `PRIMARY KEY` столбец можно сделать первичным ключом.**

```mysql
CREATE TABLE Customers 
    (
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(30),
    LastName CHARACTER VARYING(30),
    Email CHARACTER VARYING(30),
    Age INTEGER 
    );
```

 * Первичный ключ уникально идентифицирует строку в таблице. В качестве первичного ключа необязательно должны выступать столбцы с типом SERIAL, они могут представлять любой другой тип.

**Установка первичного ключа на уровне таблицы:**

```mysql
CREATE TABLE Customers
(
    Id SERIAL,
    FirstName CHARACTER VARYING(30),
    LastName CHARACTER VARYING(30),
    Email CHARACTER VARYING(30),
    Age INTEGER,
    PRIMARY KEY(Id)
);
```

* Первичный ключ может быть составным `compound key`. 
* Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать строку в таблице.

**Например:**

```mysql
CREATE TABLE OrderLines
(
    OrderId INTEGER,
    ProductId INTEGER,
    Quantity INTEGER,
    Price MONEY,
    PRIMARY KEY(OrderId, ProductId)
);
```
* Здесь поля **OrderId** и **ProductId** вместе выступают как составной первичный ключ. 
* То есть в таблице **OrderLines** не может быть двух строк, где для обоих из этих полей одновременно были бы одни и те же значения.

### `UNIQUE`

**Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут `UNIQUE`.**

```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30) UNIQUE,
    Phone CHARACTER VARYING(30) UNIQUE,
    Age INTEGER
);
```
* В данном случае столбцы, которые представляют электронный адрес и телефон, будут иметь уникальные значения. 
* И мы не сможем добавить в таблицу две строки, у которых значения для этих столбцов будет совпадать.

**Также мы можем определить этот атрибут на уровне таблицы:**

```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(30),
    Age INTEGER,
    UNIQUE(Email, Phone)
);
```
**Или так:**
    
```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(30),
    Age INTEGER,
    UNIQUE(Email), 
    UNIQUE(Phone)
);
```

### `NULL и NOT NULL`

* Чтобы указать, может ли столбец принимать значение `NULL`, при определении столбца ему можно задать атрибут `NULL` или `NOT NULL`. 
* Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение `NULL`. 
* Исключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае по умолчанию столбец имеет значение `NOT NULL`.

```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Age INTEGER
);
```

### `DEFAULT`

* Атрибут `DEFAULT` определяет значение по умолчанию для столбца. 
* Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.

```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Age INTEGER DEFAULT 18
);
```
* Здесь для столбца Age предусмотрено значение по умолчанию 18.

### `CHECK`

* Ключевое слово `CHECK` задает ограничение для диапазона значений, которые могут храниться в столбце. 
* Для этого после слова `CHECK` указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. 

**Например, возраст клиентов не может быть меньше 0 или больше 100:**
```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Age INTEGER DEFAULT 18 CHECK(Age >0 AND Age < 100),
    Email CHARACTER VARYING(30) UNIQUE CHECK(Email !=''),
    Phone CHARACTER VARYING(20) UNIQUE CHECK(Phone !='')
);
```

* Здесь также указывается, что столбцы **Email** и **Phone** не могут иметь пустую строку в качестве значения (пустая строка не эквивалентна значению `NULL`).
* Для соединения условий используется ключевое слово `AND`. Условия можно задать в виде операций сравнения больше (>), меньше (<), не равно (!=).

**Также с помощью `CHECK` можно создать ограничение в целом для таблицы:**
```mysql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    Age INTEGER DEFAULT 18,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30) UNIQUE,
    Phone CHARACTER VARYING(20) UNIQUE,
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
);
```

### Оператор `CONSTRAINT`. Установка имени ограничений.

* С помощью ключевого слова `CONSTRAINT` можно задать имя для ограничений. 
* В качестве ограничений могут использоваться `PRIMARY KEY`, `UNIQUE`, `CHECK`.

**Имена ограничений можно задать на уровне столбцов. Они указываются после `CONSTRAINT` перед атрибутами:**

```mysql
CREATE TABLE Customers
(
    Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,
    Age INTEGER CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Email CHARACTER VARYING(30) CONSTRAINT customers_email_key UNIQUE,
    Phone CHARACTER VARYING(20) CONSTRAINT customers_phone_key UNIQUE
);
```
* В принципе необязательно задавать имена ограничений, при установке соответствующих атрибутов **SQL Server** автоматически определяет их имена. 
* Но, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.

**И также можно задать все имена ограничений через атрибуты таблицы:**
```MySQL
CREATE TABLE Customers
(
    Id SERIAL,
    Age INTEGER,
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(20),
    CONSTRAINT customer_Id PRIMARY KEY(Id),
    CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),
    CONSTRAINT customers_email_key UNIQUE(Email),
    CONSTRAINT customers_phone_key UNIQUE(Phone)
);
```

* Вне зависимости от того, используется оператор `CONSTRAINT` для создания ограничений или нет (в этом случае при установке ограничений **PostgreSQL** сам дает им имена), мы можем просмотреть все ограничения в **pgAdmin** в узле базы данных в подузле **Constraints**

## 1.4 `ALTER TABLE` - изменение таблиц.

* Нередко возникает изменить уже имеющуюся таблицу, в частности, добавить или удалить столбцы, изменить тип столбцов и т.д.. 
* То есть потребуется изменить определение таблицы. 
* Для этого применяется выражение `ALTER TABLE`, которое имеет следующий формальный синтаксис:

```MySQL
ALTER TABLE название_таблицы
{ ADD название_столбца тип_данных_столбца [ограничения_столбца] | 
  DROP COLUMN название_столбца |
  ALTER COLUMN название_столбца параметры_столбца |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
```

### `ADD` - добавление нового столбца.

**Добавим в таблицу Customers новый столбец Phone:**
```MySQL
ALTER TABLE Customers ADD Phone CHARACTER VARYING(20) NULL;
```

* Здесь столбец Phone имеет тип CHARACTER VARYING(20), и для него определен атрибут NULL, то есть столбец допускает отсутствие значения. 

### `DROP` - удаление столбца.

**Удалим столбец Address из таблицы Customers:**
    
```MySQL
ALTER TABLE Customers DROP COLUMN Address;
```

### `TYPE` - изменение типа данных столбца.

- **Изменим в таблице Customers тип данных у столбца FirstName на VARCHAR(50) (он же VARYING CHARACTER(50)):**
```mysql
ALTER TABLE Customers ALTER COLUMN FirstName TYPE VARCHAR(50);
```

### `SET` - изменение ограничений столбца.

- **Установим для столбца FirstName ограничение NOT NULL:**

```mysql
ALTER TABLE Customers ALTER COLUMN FirstName SET NOT NULL;
```

- Для удаления ограничения применяется оператор `DROP`, после которого указывается ограничение.
- **Например, удалим выше установленное ограничение:**
```mysql
ALTER TABLE Customers ALTER COLUMN FirstName DROP NOT NULL;
```

### `Изменение ограничений таблицы`

* **Добавление ограничения `CHECK`:**
```mysql
ALTER TABLE Customers ADD CHECK (Age > 0);
```

* **Добавление первичного ключа `PRIMARY KEY`:**
```mysql
ALTER TABLE Customers ADD PRIMARY KEY (Id)
```
* В данном случае предполагается, что в таблице уже есть столбец **Id**, который не имеет ограничения **PRIMARY KEY**. 
* А с помощью вышеуказанного скрипта устанавливается ограничение **PRIMARY KEY**.

* **Добавление ограничение `UNIQUE` - определим для столбца Email уникальные значения:**
```mysql
ALTER TABLE Customers ADD UNIQUE (Email);
```
* При добавлении ограничения каждому из них дается определенное имя. 
* Например, выше добавленное ограничение для **CHECK** будет называться customers_age_check. 
* Имена ограничений можно посмотреть в таблице через **pgAdmin**.

* **Также мы можем явным образом назначить ограничению при добавлении имя с помощью оператора `CONSTRAINT`.**
```mysql
ALTER TABLE Customers ADD CONSTRAINT phone_unique UNIQUE (Phone);
```
* В данном случае ограничение будет называться "phone_unique".

* **Чтобы удалить ограничение, надо знать его имя, которое указывается после выражения `DROP CONSTRAINT`.**
* **Например, удалим выше добавленное ограничение:**

```mysql
ALTER TABLE Customers DROP CONSTRAINT phone_unique;
```

### `RENAME` - переименование столбца и таблицы

 * Переименуем столбец Address в City:
```mysql
ALTER TABLE Customers RENAME COLUMN Address TO City;
```

* Переименуем таблицу Customers в Users:
```mysql
ALTER TABLE Customers RENAME TO Users;
```

## 1.5 `DROP TABLE` - удаление таблиц.

**Например, удаление таблицы customers:**
```mysql
DROP TABLE customers;
```

**Удаление нескольких таблиц:**
```mysql
DROP TABLE customers, students;
```


```python

```
