*Последние изменения внесены 13.03.2023*

# Сериализация и Десереализация.

> `Сериализация` — процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных или файл. Эта операция предназначена для того, чтобы сохранить состояния объекта для последующего воссоздания при необходимости. Обратный процесс называется десериализацией.

# XML файлы 

Документация: https://docs.python.org/3/library/xml.etree.elementtree.html

> **XML** - язык разметки, позволяющий содавать структурированные документы практически любой сложности. (_примеры XML файлов: DOCX, XLSX, RSS, SVG_ и прочие.)

> **XML** файлы часто используются для передачи информации и хранения настроек серверов.

> **XML** файл представляет собой набор вложенных тегов с какой то информацией и атрибутами.

## Начало работы с файлом XML

Содержание файла `kinopoisk.xml`:
```xml
<films>
    <film name="Железный человек" original_name="Iron Man">
        <year>2008</year>
        <duration>127</duration>
        <rating>7.891</rating>
        <actors>
            <actor id="785" name="Роберт Дауни мл."/>
            <actor id="984" name="Джефф Бриджес"/>
            <actor id="1135" name="Гвинет Пэлтроу"/>
            <actor id="985" name="Терренс Ховард"/>
        </actors>
    </film>
    <film name="Мстители: Война бесконечности" original_name="Avengers: Infinity War" top250="149">
        <year>2018</year>
        <duration>149</duration>
        <rating>8.018</rating>
        <actors>
            <actor id="785" name="Роберт Дауни мл."/>
            <actor id="9841" name="Крис Хемсворт"/>
            <actor id="8174" name="Марк Руффало"/>
        </actors>
    </film>
    <film name="Человек-паук" original_name="Spider-Man">
        <year>2002</year>
        <duration>121</duration>
        <rating>7.549</rating>
        <actors>
            <actor id="948" name="Тоби Магуайр"/>
            <actor id="145" name="Уиллем Дефо"/>
            <actor id="8174" name="Кирстен Данст"/>
        </actors>
    </film>
</films>
```

### класс `ElementTree` методы `.parse()` , `.getroot()` , `.tag`

```python
#Импортируем класс ElementTree, который необходим для построения дерева элементов на основании XML файла:
import xml.etree.ElementTree as ET

#парсим документ и строим дерево:
tree = ET.parse('file_name') 

#получаем корневой элемент дерева (самый первый тег), внутри которого находятся все остальные теги документа:
root = tree.getroot()

#Выведем имя корневого тега:
print(root.tag)
```
*Результат:*

films

> Понимая с каким тегами и данными работаем, мы можем выбирать более подходящие и понятные имена для переменных.


Изменим **root** на **films**:
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk.xml')
films = tree.getroot()
```

### Кодировка и `.XMLParser(encoding='кодировка')`

> **Python** по умолчанию открывает файлы в кодировке **"utf-8"** (распространённый стандарт кодирования символов, позволяющий более компактно хранить и передавать символы Юникода)

> Если данные в файле записаны в формате **"utf-8"**,  а в служебной информации файла указан другая кодировка, Python не сможет прочитать данные.

>Чтобы проигнорировать кодировку в служебной информации файла и принудительно прочитать его данные в кодировке **"utf-8"** необходимо воспользоваться  `.XMLParser(encoding='')` *см.пример кода ниже*

**Пример кода с применением `XMLParser()`:**

```python
import xml.etree.ElementTree as ET

parser = ET.XMLParser(encoding='utf-8')
tree = ET.parse('имя_файла', parser)

```

### Работа с тегами и атрибутами в цикле. Методы `.tag` , `.attrib`, `.text`

* `.tag` - возвращает имя тега.
* `.attrib` - возвращает словарь, где ключем является название атрибута.
* `.text` - возвращает текст содержащийся внутри тега.


Содержание файла `kinopoisk.xml` без изменений:

**Выполним код:**
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk.xml')
films = tree.getroot()

# Используя циклы мы можем перебирать теги по аналогии с элементами списка:
for film in films:
    print(film.tag, film.attrib)
```

_Получим результат:_
```
film {'name': 'Железный человек', 'original_name': 'Iron Man'}
film {'name': 'Мстители: Война бесконечности', 'original_name': 'Avengers: Infinity War', 'top250': '149'}
film {'name': 'Человек-паук', 'original_name': 'Spider-Man'}
```

**Атрибуты тега представляют собой словарь, с которым мы можем работать используя пару ключ / значение:**
```python
for film in films:
    print(film.attrib['name'], film.attrib['original_name'], sep=' / ')
```

_Получим результат:_
```
Железный человек / Iron Man
Мстители: Война бесконечности / Avengers: Infinity War
Человек-паук / Spider-Man
```

**Работать с тегами через цикл можно на разной глубине вложенности:**

```python
for film in films:
    for elem in film:
        print(elem.tag, elem.text)
```
*Получим результат:*
    
```
year 2008
duration 127
rating 7.891
actors 
            
year 2018
duration 149
rating 8.018
actors 
            
year 2002
duration 121
rating 7.549
actors 
```

### Пример 1.

Используем в комплексе все рассмотренные методы работы с файлом XML и получим:
* Название фильма
* Год выхода
* Продолжительность
* Рейтинг
* Имена актеров

**Выполним код:**
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk.xml')
films = tree.getroot()

for film in films:
    print(film.attrib['name'])

    for data in film:
        if data.tag == 'year':
            print('    {}'.format(data.text))

        if data.tag in ['duration', 'rating']:
            print('    {}'.format(data.text))

        if data.tag == 'actors':
            for actor in data:
                print('    -{}'.format(actor.attrib['name']))
```

_Результат выполнения кода_:
```
Железный человек
    2008
    127
    7.891
    -Роберт Дауни мл.
    -Джефф Бриджес
    -Гвинет Пэлтроу
    -Терренс Ховард
Мстители: Война бесконечности
    2018
    149
    8.018
    -Роберт Дауни мл.
    -Крис Хемсворт
    -Марк Руффало
Человек-паук
    2002
    121
    7.549
    -Тоби Магуайр
    -Уиллем Дефо
    -Кирстен Данст
```

### Метод `.iter()`

> Метод `.iter()` - рекурсивно обходит все поддеревья в рамкаx тега, к которому применен и находит все запрашиваемые в скобках теги, как бы глубоко они не лежали в поддеревьях.

Содержание файла `kinopoisk.xml` без изменений:

Используя метод `.iter()` оптимизируем наш код и получим доступ к актерам напрямую через тег **film**, используя в качестве аргумента для поиска тег **actor**, при этом минуя дополнительного цикла по тегу **actors**.

**Выполним код:**
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk.xml')
films = tree.getroot()

for film in films:
    print(film.attrib['name'])

    #Применение метода .iter()
    for actor in film.iter('actor'):
        print('    -{}'.format(actor.attrib['name']))
```
_Получим результат:_
```
Железный человек
    -Роберт Дауни мл.
    -Джефф Бриджес
    -Гвинет Пэлтроу
    -Терренс Ховард
Мстители: Война бесконечности
    -Роберт Дауни мл.
    -Крис Хемсворт
    -Марк Руффало
Человек-паук
    -Тоби Магуайр
    -Уиллем Дефо
    -Кирстен Данст
```

##  xPath

> `xPath` - язык, позволяющий получить доступ и извлечь определенную часть данных документа.

Содержание файла `kinopoisk2.xml`:
```xml
<films>
    <film name="Железный человек" original_name="Iron Man">
        <year>2008</year>
        <duration>127</duration>
        <rating>7.891</rating>
        <actors>
            <celebrity id="785" name="Роберт Дауни мл." sex="m"/>
            <celebrity id="984" name="Джефф Бриджес" sex="m"/>
            <celebrity id="1135" name="Гвинет Пэлтроу" sex="w"/>
            <celebrity id="985" name="Терренс Ховард" sex="m"/>
        </actors>
        <directors>
            <celebrity id="124" name="Джон Фавро" sex="m"/>
        </directors>
    </film>
    <film name="Мстители: Война бесконечности" original_name="Avengers: Infinity War" top250="149">
        <year>2018</year>
        <duration>149</duration>
        <rating>8.018</rating>
        <actors>
            <celebrity id="785" name="Роберт Дауни мл." sex="m"/>
            <celebrity id="9841" name="Крис Хемсворт" sex="m"/>
            <celebrity id="8174" name="Марк Руффало" sex="m"/>
        </actors>
        <directors>
            <celebrity id="1458" name="Энтони Руссо" sex="m"/>
            <celebrity id="1448" name="Джо Руссо" sex="m"/>
        </directors>
    </film>
    <film name="Человек-паук" original_name="Spider-Man">
        <year>2002</year>
        <duration>121</duration>
        <rating>7.549</rating>
        <actors>
            <celebrity id="948" name="Тоби Магуайр" sex="m"/>
            <celebrity id="145" name="Уиллем Дефо" sex="m"/>
            <celebrity id="8174" name="Кирстен Данст" sex="m"/>
        </actors>
        <directors>
            <celebrity id="91855" name="Сэм Рэйми" sex="m"/>
        </directors>
    </film>
</films>
```

**Попробуем получить именя всех актеров:**

**Выполним код:**
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk2.xml')
films = tree.getroot()

for actor in films.iter('celebrity'):
    print(actor.attrib['name'])
```

_В результате мы получим все значения имен атрибута **name** внутри тегов **actors** и **directors**_, что не соответсвует поставленной задачи в полной мере:
```
Роберт Дауни мл.
Джефф Бриджес
Гвинет Пэлтроу
Терренс Ховард
Джон Фавро
Роберт Дауни мл.
Крис Хемсворт
Марк Руффало
Энтони Руссо
Джо Руссо
Тоби Магуайр
Уиллем Дефо
Кирстен Данст
Сэм Рэйми

```

### Метод `.find()`

**Воспользуемся методом`.find` и `xPath` выражением, которое мы указываем в скобках:**

**Выполним код:**
```python
import xml.etree.ElementTree as ET

tree = ET.parse('kinopoisk2.xml')
films = tree.getroot()

name = films.find('.//celebrity')

print(name.attrib['name'])
```
*Результат:*

Роберт Дауни мл.

* В результате применения метода `.find()` к "корню нашего дерева" мы находим первое совпадение по тегу **'celebrity'** и выводим значение атрибута **'name'**.
* На этом поиск прекращается.

* Следует обратить внимание, что в результате работы метода `.find()` мы оказались внутри тега **'actors'**, по сути являющегося списком из 4 элементов - тегов **'celebrity'** имеющих одинаковые атрибуты, но разные значения атрибутов.
* Добавив **индекс** конкретного элемента в `xPath` выражение, мы можем принудительно проигнорировать первые совпадения и один раз обратится к конкретному тегу **'celebrity'** внутри **'actors'**, после чего поиск прекратится:

**Выполним код:**
```python
import xml.etree.ElementTree as ET

tree = ET.parse('kinopoisk2.xml')
films = tree.getroot()

name = films.find('.//celebrity[2]')
print(name.attrib['name'])
```
*Получим результат:*

Джефф Бриджес

### Метод`.findall()`

**Воспользуемся методом`.findall` и `xPath` выражением, которое мы указываем в скобках:**

> Важно помнить что метод `.findall()` возвращает нам **XML** документ!!! Следовательно мы можем применять к нему все ранее изученные методы для получения необходимого результата.

**Выполним код:**
```python
import xml.etree.ElementTree as ET
tree = ET.parse('kinopoisk2.xml')
films = tree.getroot()

#Выражение xPath начинается с точки, которая означает корень нашего дерева.
#В нашем случаем .findall применяется к тегу films, а значит films и будет корнем.
#Далее мы указываем путь до нужного нам тега, где каждый элемент пути это какой то тег.
#В результате работы метода .findall() actor будет содержать XML документ.
#Поэтому к actor мы можем применить метод .attrib() и получить необходимый результат:
for actor in films.findall('./film/actors/celebrity'):
    print(actor.attrib['name'])
```

*Получим требуемый результат вывода всех имен актеров:*
```
Роберт Дауни мл.
Джефф Бриджес
Гвинет Пэлтроу
Терренс Ховард
Роберт Дауни мл.
Крис Хемсворт
Марк Руффало
Тоби Магуайр
Уиллем Дефо
Кирстен Данст
```

### Дополнительные параметры запроса в выражении `xPath`

### `Поиск по индексу элемента.`

> Получения элемента с определенным индексом:
    
**Дополним запрос `xPath`, выполним код и получим только имена актеров, которые указанные первыми:**
```python
for actor in films.findall('./film/actors/celebrity[1]'): #Указываем [1] так как нумерация в XML начинается с единицы.
    print(actor.attrib['name'])
```
*Результат:*
```
Роберт Дауни мл.
Роберт Дауни мл.
Тоби Магуайр
```

### `Поиск по значению атрибута.`

> При обращениее к атрибуту тега, перед именем тега необходимо использовать символ @

**Получения элемента с определенным атрибутом:**
    
Дополним запрос `xPath`, выполним код и получим только имена актеров женщин:

```python
#В выражении xPath мы убрали промежуточный тег, оставив на его месте двойной слэш //
#Теперь поиcк будет производиться внутри всего тега film по тегу celebrity.
for celebrity in films.findall("./film//celebrity[@sex='w']"):
    print(celebrity.attrib['name'])
```
*Результат:*
```
Гвинет Пэлтроу
```

### `Поиск по наличию атрибута.`

> При обращениее к атрибуту тега, перед именем тега необходимо использовать символ @

**Получения элемента с имеющим определенный атрибут:**

Дополним запрос `xPath`, выполним код и получим фильмы входящие в топ 250, то есть имеющие атрибут **top250**:

```python
#В выражении xPath мы указывам тег, внутри которого будет производится поиск атрибута и имя искомого атрибута, значение атрибута не указываем.
for film in films.findall("./film[@top250]"):
    print(film.attrib['name'])

```
*Результат:*
```
Мстители: Война бесконечности
```

### `Поиск по значению внутри тега.`

> При обращениее к тегу, мы просто указываем его имя и значение в кавычках через знак =

**Получения элемента с определенным значение внутри тега:**

Дополним запрос `xPath`, выполним код и получим фильмы которые вышли в прокат в 2002 году:

```python
#В выражении xPath мы указывам тег, внутри которого будет производится поиск указанного значения.
for film in films.findall('./film[year="2002"]'):
    print(film.attrib['name'])

```
*Результат:*
```
Человек-паук
```
